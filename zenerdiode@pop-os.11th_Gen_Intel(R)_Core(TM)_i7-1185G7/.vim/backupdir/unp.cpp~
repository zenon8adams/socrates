#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <cstring>
#include <unistd.h>
#include <errno.h>
#include <string_view>
#include <iostream>
#include <memory>
#include "unp.h"

void err_sys( std::string_view message)
{
    std::string err_buf( 256, 0);
    std::cerr << message << ": "
              << strerror_r( errno, &err_buf[ 0], 
                             err_buf.size()) << '\n';
    exit( errno);
}

int Socket( int domain, int type, int protocol)
{
    auto fd = socket( domain, type, protocol); 
    if( fd < 0)
        err_sys( "socket error");

    return fd;
}


int Bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen)
{
    auto rv = bind( sockfd, addr, addrlen);
    if( rv < 0)
        err_sys( "bind error");

    return rv;
}

int Listen(int sockfd, int backlog)
{
    auto rv = listen( sockfd, backlog);
    if( rv < 0)
        err_sys( "listen error");

    return rv;
}

int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
{
    auto rv = accept( sockfd, SA( addr), addrlen);
    if( rv < 0)
        err_sys( "accept error");

    return rv;
}

ssize_t Write(int fd, const void *buf, size_t count)
{
    auto n_written = write( fd, buf, count);
    if( n_written < 0)
        err_sys( "write error");

    return n_written;
}

int Close( int fd)
{
    auto rv = close( fd);
    if( rv < 0)
        err_sys( "close error");

    return rv;
}

int Inet_pton(int af, const char *src, void *dst, 
              const char *err_pfx)
{
    int rv = inet_pton( af, src, dst);
    if( rv <= 0)
    {
        if( err_pfx != nullptr)
            err_quit( "inet_pton error for %s", err_pfx);
        else
            err_sys( "inet_pton error");
    }

    return rv;
}
int Connect(int sockfd, const struct sockaddr *addr,
                   socklen_t addrlen)
{
    int rv = connect( sockfd, addr, addrlen);
    if( rv < 0)
        err_sys( "connect error");

    return rv;
}

std::string sock_ntop(const struct sockaddr *sa, socklen_t sa_len)
{
    std::string str( 128, 0);
    switch( sa->sa_family)
    {
        case AF_INET:
        {
            auto *sin = reinterpret_cast<const struct sockaddr_in *>( sa);
            if( inet_ntop( AF_INET, &sin->sin_addr, &str[0], str.size()) == NULL)
                return nullptr;
            if( ntohs( sin->sin_port) != 0)
                str.append( ":").append( std::to_string( ntohs( sin->sin_port)));

            return str;
        }
        case AF_INET6:
        {
            auto *sin = reinterpret_cast<const struct sockaddr_in6 *>( sa);
            if( inet_ntop( AF_INET6, &sin->sin6_addr, &str[0], str.size()) == NULL)
                return nullptr;
            if( ntohs( sin->sin6_port) != 0)
                str.append( ":").append( std::to_string( ntohl( sin->sin6_port)));

            return str;
        }
    }
    return str;
}

ssize_t readn( int fd, void *vptr, size_t n)
{
    auto *ptr = static_cast<char *>( vptr);
    auto nleft = n;
    while( nleft > 0)
    {
        auto nread = read( fd, ptr, nleft); 
        if( nread < 0)
        {
            if( errno == EINTR)
                nread = 0;
            else
                return -1;
        }
        else if( nread == 0)
            break;

        nleft -= nread;
        ptr += nread;
    }

    return n - nleft;
}

ssize_t writen( int fd, const void *vptr, size_t n)
{
    auto *ptr = static_cast< const char *>( vptr);
    auto nleft = n;
    while( nleft > 0)
    {
        auto n_written = write( fd, ptr, nleft);
        if( n_written <= 0 && errno == EINTR)
            n_written = 0;
        else
            return -1;
        nleft -= n_written;
        ptr += n_written;
    }

    return n;
}

ssize_t readline( int fd, void *vptr, size_t maxlen)
{
    auto *ptr = static_cast<char *>( vptr);
    size_t i = 1;
    for( ; i < maxlen; ++i)
    {
        int c;
        int rc = read( fd, &c, 1);
        if( rc == 1)
        {
            *ptr++ = c;
            if( c == '\n')
                break;
        }
        else if( rc == 0)
        {
            *ptr = 0;
            return i - 1;
        }
        else if( errno == EINTR)
            continue;
        else
            return -1;
    }
    *ptr = 0;
    return i;
}
