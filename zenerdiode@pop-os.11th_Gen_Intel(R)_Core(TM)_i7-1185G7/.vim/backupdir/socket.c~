#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/sock_diag.h>
#include <linux/unix_diag.h>
#include <stdint.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/inet_diag.h>
#include <stdlib.h>

static int send_query(int fd) {
	struct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };
	struct {
		struct nlmsghdr nlh;
		struct inet_diag_req_v2 udr;
	} req			  = { .nlh = { .nlmsg_len	= sizeof(req),
								   .nlmsg_type	= SOCK_DIAG_BY_FAMILY,
								   .nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP },
						  .udr = { .sdiag_family   = AF_INET,
								   .sdiag_protocol = IPPROTO_TCP,
								   .idiag_states   = (uint32_t)-1 } };
	struct iovec iov  = { .iov_base = &req, .iov_len = sizeof(req) };
	struct msghdr msg = { .msg_name	   = &nladdr,
						  .msg_namelen = sizeof(nladdr),
						  .msg_iov	   = &iov,
						  .msg_iovlen  = 1 };

	for (;;) {
		if (sendmsg(fd, &msg, 0) < 0) {
			if (errno == EINTR)
				continue;

			perror("sendmsg");
			return -1;
		}

		return 0;
	}
}

static int print_diag(const struct unix_diag_msg *diag, unsigned int len) {
	if (len < NLMSG_LENGTH(sizeof(*diag))) {
		fputs("short response\n", stderr);
		return -1;
	}
	if (diag->udiag_family != AF_UNIX) {
		fprintf(stderr, "unexpected family %u\n", diag->udiag_family);
		return -1;
	}

	unsigned int rta_len = len - NLMSG_LENGTH(sizeof(*diag));
	unsigned int peer	 = 0;
	size_t path_len		 = 0;
	char path[sizeof(((struct sockaddr_un *)0)->sun_path) + 1];

	for (struct rtattr *attr = (struct rtattr *)(diag + 1);
		 RTA_OK(attr, rta_len);
		 attr = RTA_NEXT(attr, rta_len)) {
		switch (attr->rta_type) {
			case UNIX_DIAG_NAME:
				if (!path_len) {
					path_len = RTA_PAYLOAD(attr);
					if (path_len > sizeof(path) - 1)
						path_len = sizeof(path) - 1;
					memcpy(path, RTA_DATA(attr), path_len);
					path[path_len] = '\0';
				}
				break;

			case UNIX_DIAG_PEER:
				if (RTA_PAYLOAD(attr) >= sizeof(peer))
					peer = *(unsigned int *)RTA_DATA(attr);
				break;
		}
	}

	printf("inode=%u", diag->udiag_ino);

	if (peer)
		printf(", peer=%u", peer);

	if (path_len)
		printf(", name=%s%s", *path ? "" : "@", *path ? path : path + 1);

	putchar('\n');
	return 0;
}
static int receive_responses(int fd, int *last) {
	long buf[8192 / sizeof(long)];
	struct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };
	struct iovec iov		  = { .iov_base = buf, .iov_len = sizeof(buf) };
	int flags				  = 0;

	int last_offset = *last;
	int this_offset = 0;
	for (;;) {
		struct msghdr msg = { .msg_name	   = &nladdr,
							  .msg_namelen = sizeof(nladdr),
							  .msg_iov	   = &iov,
							  .msg_iovlen  = 1 };

		ssize_t ret = recvmsg(fd, &msg, flags);

		if (ret < 0) {
			if (errno == EINTR)
				continue;

			perror("recvmsg");
			return -1;
		}
		if (ret == 0)
			return 0;

		const struct nlmsghdr *h = (struct nlmsghdr *)buf;

		if (!NLMSG_OK(h, ret)) {
			fputs("!NLMSG_OK\n", stderr);
			return -1;
		}

		for (; NLMSG_OK(h, ret); h = NLMSG_NEXT(h, ret)) {
			if (h->nlmsg_type == NLMSG_DONE) {
				*last = this_offset;
				return 0;
			}

			if (last_offset >= 0) {
				if (this_offset < last_offset) {
					++this_offset;
					continue;
				}
			} else {
				++this_offset;
			}

			struct inet_diag_msg *msg = (struct inet_diag_msg *)NLMSG_DATA(h);
			struct sockaddr_in src, dst;

			if (h->nlmsg_type == NLMSG_ERROR) {
				const struct nlmsgerr *err =
					(const struct nlmsgerr *)NLMSG_DATA(h);

				if (h->nlmsg_len < NLMSG_LENGTH(sizeof(*err))) {
					fputs("NLMSG_ERROR\n", stderr);
				} else {
					errno = -err->error;
					perror("NLMSG_ERROR");
				}

				return -1;
			}

			if (h->nlmsg_type != SOCK_DIAG_BY_FAMILY) {
				fprintf(stderr,
						"unexpected nlmsg_type %u\n",
						(unsigned)h->nlmsg_type);
				return -1;
			}

			memset(&src, 0, sizeof(src));
			memset(&dst, 0, sizeof(dst));
			src.sin_family = dst.sin_family = msg->idiag_family;
			memcpy(&src.sin_addr, &msg->id.idiag_src[0], sizeof(src.sin_addr));
			memcpy(&dst.sin_addr, &msg->id.idiag_dst[0], sizeof(dst.sin_addr));

			printf("Source IP: %s\n", inet_ntoa(src.sin_addr));
			printf("Destination IP: %s\n", inet_ntoa(dst.sin_addr));
			printf("Source Port: %d\n", ntohs(msg->id.idiag_sport));
			printf("Destination Port: %d\n", ntohs(msg->id.idiag_dport));
			printf("Socket inode: %u\n", msg->idiag_inode);
		}
	}
}

int main(void) {
	int fd			= socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG);
	int last_offset = -1;

	if (fd < 0) {
		perror("socket");
		return 1;
	}

	while (1) {
		int ret = send_query(fd) || receive_responses(fd, &last_offset);
		if (ret < 0) {
			exit(ret);
		}
		// close(fd);
		sleep(1);
	}
}
