const { GObject } = imports.gi;

var SignalsHandlerFlags = {
  NONE: 0,
  CONNECT_AFTER: 1
};
/**
 * Simplify global signals and function injections handling
 * abstract class
 */
const BasicHandler = class BasicHandler {
  constructor(parentObject) {
    this._storage = new Object();

    if (parentObject) {
      if (!(parentObject.connect instanceof Function))
        throw new TypeError('Not a valid parent object');

      if (
        !(parentObject instanceof GObject.Object) ||
        GObject.signal_lookup('destroy', parentObject.constructor.$gtype)
      ) {
        this._parentObject = parentObject;
        this._destroyId = parentObject.connect('destroy', () => this.destroy());
      }
    }
  }

  add(...args) {
    // Convert arguments object to array, concatenate with generic
    // Call addWithLabel with ags as if they were passed arguments
    this.addWithLabel('generic', ...args);
  }

  destroy() {
    this._parentObject?.disconnect(this._destroyId);
    this._parentObject = null;

    for (let label in this._storage) this.removeWithLabel(label);
  }

  block() {
    Object.keys(this._storage).forEach((label) => this.blockWithLabel(label));
  }

  unblock() {
    Object.keys(this._storage).forEach((label) => this.unblockWithLabel(label));
  }

  addWithLabel(label, ...args) {
    let argsArray = [...args];
    if (argsArray.every((arg) => !Array.isArray(arg))) argsArray = [argsArray];

    if (this._storage[label] == undefined) this._storage[label] = new Array();

    // Skip first element of the arguments
    for (const argArray of argsArray) {
      if (argArray.length < 3)
        throw new Error('Unexpected number of arguments');
      let item = this._storage[label];
      try {
        item.push(this._create(...argArray));
      } catch (e) {
        logError(e);
      }
    }
  }

  removeWithLabel(label) {
    this._storage[label]?.reverse().forEach((item) => this._remove(item));
    delete this._storage[label];
  }

  blockWithLabel(label) {
    (this._storage[label] || []).forEach((item) => this._block(item));
  }

  unblockWithLabel(label) {
    (this._storage[label] || []).forEach((item) => this._unblock(item));
  }

  // Virtual methods to be implemented by subclass

  /**
   * Create single element to be stored in the storage structure
   */
  _create(_object, _element, _callback) {
    throw new GObject.NotImplementedError(
      `_create in ${this.constructor.name}`
    );
  }

  /**
   * Correctly delete single element
   */
  _remove(_item) {
    throw new GObject.NotImplementedError(
      `_remove in ${this.constructor.name}`
    );
  }

  /**
   * Block single element
   */
  _block(_item) {
    throw new GObject.NotImplementedError(`_block in ${this.constructor.name}`);
  }

  /**
   * Unblock single element
   */
  _unblock(_item) {
    throw new GObject.NotImplementedError(
      `_unblock in ${this.constructor.name}`
    );
  }
};

/**
 * Manage global signals
 */
var GlobalSignalHandler = class GlobalSignalHandler extends BasicHandler {
  _create(object, event, callback, flags = SignalsHandlerFlags.NONE) {
    if (!object) throw new Error('Impossible to connect to an invalid object');

    let after = flags == SignalsHandlerFlags.CONNECT_AFTER;
    let connector = after ? object.connect_after : object.connect;

    if (!connector) {
      throw new Error(
        `Requested to connect to signal '${event}', ` +
          `but no implementation for 'connect${after ? '_after' : ''}' ` +
          `found in ${object.constructor.name}`
      );
    }

    let id = connector.call(object, event, callback);

    return [object, id];
  }

  _remove(item) {
    const [object, id] = item;
    object.disconnect(id);
  }

  _block(item) {
    const [object, id] = item;

    if (object instanceof GObject.Object)
      GObject.Object.prototype.block_signal_handler.call(object, id);
  }

  _unblock(item) {
    const [object, id] = item;

    if (object instanceof GObject.Object)
      GObject.Object.prototype.unblock_signal_handler.call(object, id);
  }
};
